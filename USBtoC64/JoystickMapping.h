#pragma once
#include <Arduino.h>
#include <stdint.h>

// Generated by the USBtoC64 Configurator (WebHID)
// Device: NES Controller USB
// Vendor ID: 4754
// Product ID: 17987
// Preferred C64 timing (firmware PAL macro): PAL

#define JOY_MAP_LEARN   0
#define JOY_MAP_CUSTOM  1

#define JOY_MAPPING_MODE JOY_MAP_CUSTOM

#if (JOY_MAPPING_MODE == JOY_MAP_CUSTOM)

enum JM_Op : uint8_t {
  JM_EQ = 0,
  JM_BITANY = 1
};

enum JM_Func : uint8_t {
  JM_UP = 0,
  JM_UP_RIGHT,
  JM_RIGHT,
  JM_RIGHT_DOWN,
  JM_DOWN,
  JM_DOWN_LEFT,
  JM_LEFT,
  JM_LEFT_UP,
  JM_FIRE,
  JM_FIRE2,
  JM_FIRE3,
  JM_AUTOFIRE_ON,
  JM_AUTOFIRE_OFF,
  JM_AUTOLEFTRIGHT_ON,
  JM_AUTOLEFTRIGHT_OFF
};

struct JM_Rule {
  uint8_t index;
  uint8_t value;
  JM_Op op;
  JM_Func func;
};

static bool JM_autofire = false;
static bool JM_autoleftright = false;

#define JM_DPAD_INDEX 0
#define JM_HAS_DPAD_INDEX 1

static const JM_Rule JM_JOY_RULES[] = {
  { 0, 8, JM_EQ, JM_UP },
  { 0, 9, JM_EQ, JM_UP_RIGHT },
  { 0, 1, JM_EQ, JM_RIGHT },
  { 0, 5, JM_EQ, JM_RIGHT_DOWN },
  { 0, 4, JM_EQ, JM_DOWN },
  { 0, 6, JM_EQ, JM_DOWN_LEFT },
  { 0, 2, JM_EQ, JM_LEFT },
  { 0, 10, JM_EQ, JM_LEFT_UP },
  { 1, 2, JM_EQ, JM_FIRE },
  { 1, 1, JM_EQ, JM_UP },
  { 1, 4, JM_EQ, JM_AUTOLEFTRIGHT_OFF },
  { 1, 8, JM_EQ, JM_AUTOFIRE_ON },
};
static const size_t JM_JOY_RULES_COUNT = sizeof(JM_JOY_RULES) / sizeof(JM_JOY_RULES[0]);

static const JM_Rule JM_MOUSE_BTN_RULES[] = {
  { 1, 2, JM_EQ, JM_FIRE },
  { 1, 1, JM_EQ, JM_UP },
  { 1, 4, JM_EQ, JM_AUTOLEFTRIGHT_OFF },
  { 1, 8, JM_EQ, JM_AUTOFIRE_ON },
};
static const size_t JM_MOUSE_BTN_RULES_COUNT = sizeof(JM_MOUSE_BTN_RULES) / sizeof(JM_MOUSE_BTN_RULES[0]);

#define JM_USE_ANALOG_MOUSE  0

static const uint8_t JM_MOUSE_X_INDEXES[] = { 2, 4 };
static const uint8_t JM_MOUSE_Y_INDEXES[] = { 3, 5 };

#define JM_ANALOG_CENTER      127
#define JM_ANALOG_DEAD_LOW    64
#define JM_ANALOG_DEAD_HIGH   190

#define JM_C64_ANALOG_DIV      3
#define JM_C64_Y_INVERT        1

#define JM_A_STEP_DIV          40
#define JM_A_Y_INVERT          0

#define JM_ATARI_PULSE_SCALE   18.6f

static inline bool JM_match(const JM_Rule &r, const uint8_t *data, int length) {
  if ((int)r.index >= length) return false;
  uint8_t v = data[r.index];
  if (r.op == JM_EQ) return (v == r.value);
  return ((v & r.value) != 0);
}

static inline void JM_applyDirFunc(JM_Func f, bool &up, bool &down, bool &left, bool &right) {
  switch (f) {
    case JM_UP:         up = true; break;
    case JM_UP_RIGHT:   up = true; right = true; break;
    case JM_RIGHT:      right = true; break;
    case JM_RIGHT_DOWN: down = true; right = true; break;
    case JM_DOWN:       down = true; break;
    case JM_DOWN_LEFT:  down = true; left = true; break;
    case JM_LEFT:       left = true; break;
    case JM_LEFT_UP:    up = true; left = true; break;
    default: break;
  }
}

static inline void JM_DecodeDirections(const uint8_t *data, int length,
                                      bool &up, bool &down, bool &left, bool &right) {
  up = down = left = right = false;

  for (size_t i = 0; i < JM_JOY_RULES_COUNT; i++) {
    const JM_Rule &r = JM_JOY_RULES[i];
#if (JM_HAS_DPAD_INDEX == 1)
    if ((int)r.index != JM_DPAD_INDEX) continue;
#endif
    if (!JM_match(r, data, length)) continue;
    JM_applyDirFunc(r.func, up, down, left, right);
  }
}

static inline void JM_DecodeJoystickButtons(const uint8_t *data, int length,
                                           bool &fire, bool &fire2, bool &fire3,
                                           bool &autofireEnabled, bool &autoleftrightEnabled) {
  fire = false;
  fire2 = false;
  fire3 = false;

  for (size_t i = 0; i < JM_JOY_RULES_COUNT; i++) {
    const JM_Rule &r = JM_JOY_RULES[i];
#if (JM_HAS_DPAD_INDEX == 1)
    if ((int)r.index == JM_DPAD_INDEX) continue;
#endif
    if (!JM_match(r, data, length)) continue;

    if (r.func == JM_AUTOFIRE_ON)        { JM_autofire = true;  continue; }
    if (r.func == JM_AUTOFIRE_OFF)       { JM_autofire = false; continue; }
    if (r.func == JM_AUTOLEFTRIGHT_ON)   { JM_autoleftright = true;  continue; }
    if (r.func == JM_AUTOLEFTRIGHT_OFF)  { JM_autoleftright = false; continue; }

    if (r.func == JM_FIRE)  fire = true;
    if (r.func == JM_FIRE2) fire2 = true;
    if (r.func == JM_FIRE3) fire3 = true;
  }

  autofireEnabled = JM_autofire;
  autoleftrightEnabled = JM_autoleftright;
}

// Backward-compatible API (older firmware expects a single decode call)
static inline void JM_DecodeJoystickMode(const uint8_t *data, int length,
                                        bool &up, bool &down, bool &left, bool &right,
                                        bool &fire, bool &fire2, bool &fire3,
                                        bool &autofireEnabled, bool &autoleftrightEnabled) {
  JM_DecodeDirections(data, length, up, down, left, right);
  JM_DecodeJoystickButtons(data, length, fire, fire2, fire3, autofireEnabled, autoleftrightEnabled);
}

static inline void JM_DecodeMouseModeButtons_C64(const uint8_t *data, int length,
                                                bool &fire, bool &up, bool &autofireEnabled) {
  fire = false;
  up = false;

  for (size_t i = 0; i < JM_MOUSE_BTN_RULES_COUNT; i++) {
    const JM_Rule &r = JM_MOUSE_BTN_RULES[i];
    if (!JM_match(r, data, length)) continue;

    if (r.func == JM_AUTOFIRE_ON)  { JM_autofire = true;  continue; }
    if (r.func == JM_AUTOFIRE_OFF) { JM_autofire = false; continue; }

    if (r.func == JM_FIRE) fire = true;
    if (r.func == JM_UP)   up = true;
  }

  autofireEnabled = JM_autofire;
}

static inline void JM_DecodeMouseModeButtons_A(const uint8_t *data, int length,
                                              bool &fire, bool &button2, bool &button3, bool &autofireEnabled) {
  fire = false;
  button2 = false;
  button3 = false;

  for (size_t i = 0; i < JM_MOUSE_BTN_RULES_COUNT; i++) {
    const JM_Rule &r = JM_MOUSE_BTN_RULES[i];
    if (!JM_match(r, data, length)) continue;

    if (r.func == JM_AUTOFIRE_ON)  { JM_autofire = true;  continue; }
    if (r.func == JM_AUTOFIRE_OFF) { JM_autofire = false; continue; }

    if (r.func == JM_FIRE)  fire = true;
    if (r.func == JM_FIRE2) button2 = true;
    if (r.func == JM_FIRE3) button3 = true;
    if (r.func == JM_UP)    button2 = true;
  }

  autofireEnabled = JM_autofire;
}

static inline void JM_AnalogToMouseDelta_C64(const uint8_t *data, int length, int &dX, int &dY) {
  dX = 0;
  dY = 0;

#if (JM_USE_ANALOG_MOUSE == 1)
  for (size_t i = 0; i < (sizeof(JM_MOUSE_X_INDEXES) / sizeof(JM_MOUSE_X_INDEXES[0])); i++) {
    uint8_t idx = JM_MOUSE_X_INDEXES[i];
    if ((int)idx >= length) continue;
    uint8_t v = data[idx];
    if (v < JM_ANALOG_DEAD_LOW || v > JM_ANALOG_DEAD_HIGH) {
      dX += ((int)v - JM_ANALOG_CENTER) / JM_C64_ANALOG_DIV;
    }
  }

  for (size_t i = 0; i < (sizeof(JM_MOUSE_Y_INDEXES) / sizeof(JM_MOUSE_Y_INDEXES[0])); i++) {
    uint8_t idx = JM_MOUSE_Y_INDEXES[i];
    if ((int)idx >= length) continue;
    uint8_t v = data[idx];
    if (v < JM_ANALOG_DEAD_LOW || v > JM_ANALOG_DEAD_HIGH) {
#if (JM_C64_Y_INVERT == 1)
      dY += (JM_ANALOG_CENTER - (int)v) / JM_C64_ANALOG_DIV;
#else
      dY += ((int)v - JM_ANALOG_CENTER) / JM_C64_ANALOG_DIV;
#endif
    }
  }
#endif
}

static inline void JM_AnalogToMouseSteps_A(const uint8_t *data, int length, int &xStepsSigned, int &yStepsSigned) {
  xStepsSigned = 0;
  yStepsSigned = 0;

#if (JM_USE_ANALOG_MOUSE == 1)
  for (size_t i = 0; i < (sizeof(JM_MOUSE_X_INDEXES) / sizeof(JM_MOUSE_X_INDEXES[0])); i++) {
    uint8_t idx = JM_MOUSE_X_INDEXES[i];
    if ((int)idx >= length) continue;
    uint8_t v = data[idx];
    if (v < JM_ANALOG_DEAD_LOW || v > JM_ANALOG_DEAD_HIGH) {
      xStepsSigned += ((int)v - JM_ANALOG_CENTER) / JM_A_STEP_DIV;
    }
  }

  for (size_t i = 0; i < (sizeof(JM_MOUSE_Y_INDEXES) / sizeof(JM_MOUSE_Y_INDEXES[0])); i++) {
    uint8_t idx = JM_MOUSE_Y_INDEXES[i];
    if ((int)idx >= length) continue;
    uint8_t v = data[idx];
    if (v < JM_ANALOG_DEAD_LOW || v > JM_ANALOG_DEAD_HIGH) {
#if (JM_A_Y_INVERT == 1)
      yStepsSigned += (JM_ANALOG_CENTER - (int)v) / JM_A_STEP_DIV;
#else
      yStepsSigned += ((int)v - JM_ANALOG_CENTER) / JM_A_STEP_DIV;
#endif
    }
  }
#endif
}

#else // JOY_MAPPING_MODE != JOY_MAP_CUSTOM

static inline void JM_DecodeDirections(const uint8_t*, int, bool &up, bool &down, bool &left, bool &right) {
  up = down = left = right = false;
}
static inline void JM_DecodeJoystickButtons(const uint8_t*, int, bool &fire, bool &fire2, bool &fire3,
                                           bool &autofireEnabled, bool &autoleftrightEnabled) {
  fire = false; fire2 = false; fire3 = false; autofireEnabled = false; autoleftrightEnabled = false;
}
static inline void JM_DecodeJoystickMode(const uint8_t*, int,
                                        bool &up, bool &down, bool &left, bool &right,
                                        bool &fire, bool &fire2, bool &fire3,
                                        bool &autofireEnabled, bool &autoleftrightEnabled) {
  up = down = left = right = fire = fire2 = fire3 = false;
  autofireEnabled = false;
  autoleftrightEnabled = false;
}
static inline void JM_DecodeMouseModeButtons_C64(const uint8_t*, int, bool &fire, bool &up, bool &autofireEnabled) {
  fire = false; up = false; autofireEnabled = false;
}
static inline void JM_DecodeMouseModeButtons_A(const uint8_t*, int, bool &fire, bool &button2, bool &button3, bool &autofireEnabled) {
  fire = false; button2 = false; button3 = false; autofireEnabled = false;
}
static inline void JM_AnalogToMouseDelta_C64(const uint8_t*, int, int &dX, int &dY) { dX = 0; dY = 0; }
static inline void JM_AnalogToMouseSteps_A(const uint8_t*, int, int &xStepsSigned, int &yStepsSigned) { xStepsSigned = 0; yStepsSigned = 0; }

#define JM_ATARI_PULSE_SCALE 18.6f

#endif
